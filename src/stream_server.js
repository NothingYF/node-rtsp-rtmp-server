// Generated by CoffeeScript 1.7.1
(function() {
  var CustomReceiver, DEBUG_INCOMING_PACKET_DATA, DEBUG_INCOMING_PACKET_HASH, DEFAULT_SERVER_NAME, Sequent, StreamServer, aac, avstreams, config, crypto, fs, h264, http, logger, net, packageJson, rtmp, rtsp, serverName, _ref;

  net = require('net');

  fs = require('fs');

  crypto = require('crypto');

  config = require('../config');

  rtmp = require('./rtmp');

  http = require('./http');

  rtsp = require('./rtsp');

  h264 = require('./h264');

  aac = require('./aac');

  avstreams = require('./avstreams');

  CustomReceiver = require('./custom_receiver');

  logger = require('./logger');

  packageJson = require('../package.json');

  Sequent = require('sequent');

  DEBUG_INCOMING_PACKET_DATA = false;

  DEBUG_INCOMING_PACKET_HASH = false;

  DEFAULT_SERVER_NAME = "node-rtsp-rtmp-server/" + packageJson.version;

  serverName = (_ref = config.serverName) != null ? _ref : DEFAULT_SERVER_NAME;

  StreamServer = (function() {
    function StreamServer(opts) {
      var _ref1;
      this.serverName = (_ref1 = opts != null ? opts.serverName : void 0) != null ? _ref1 : serverName;
      this.rtmpServer = new rtmp.RTMPServer;
      this.rtmpServer.on('video_start', (function(_this) {
        return function(streamId) {
          var stream;
          stream = avstreams.getOrCreate(streamId);
          return _this.onReceiveVideoControlBuffer(stream);
        };
      })(this));
      this.rtmpServer.on('video_data', (function(_this) {
        return function(streamId, pts, dts, nalUnits) {
          var stream;
          stream = avstreams.get(streamId);
          if (stream != null) {
            return _this.onReceiveVideoPacket(stream, nalUnits, pts, dts);
          } else {
            return logger.warn("warn: Received invalid streamId from rtmp: " + streamId);
          }
        };
      })(this));
      this.rtmpServer.on('audio_start', (function(_this) {
        return function(streamId) {
          var stream;
          stream = avstreams.getOrCreate(streamId);
          return _this.onReceiveAudioControlBuffer(stream);
        };
      })(this));
      this.rtmpServer.on('audio_data', (function(_this) {
        return function(streamId, pts, dts, adtsFrame) {
          var stream;
          stream = avstreams.get(streamId);
          if (stream != null) {
            return _this.onReceiveAudioPacket(stream, adtsFrame, pts, dts);
          } else {
            return logger.warn("warn: Received invalid streamId from rtmp: " + streamId);
          }
        };
      })(this));
      this.customReceiver = new CustomReceiver(config.receiverType, {
        videoControl: (function(_this) {
          return function() {
            return _this.onReceiveVideoControlBuffer.apply(_this, arguments);
          };
        })(this),
        audioControl: (function(_this) {
          return function() {
            return _this.onReceiveAudioControlBuffer.apply(_this, arguments);
          };
        })(this),
        videoData: (function(_this) {
          return function() {
            return _this.onReceiveVideoDataBuffer.apply(_this, arguments);
          };
        })(this),
        audioData: (function(_this) {
          return function() {
            return _this.onReceiveAudioDataBuffer.apply(_this, arguments);
          };
        })(this)
      });
      this.customReceiver.deleteReceiverSocketsSync();
      this.httpHandler = new http.HTTPHandler({
        serverName: this.serverName,
        documentRoot: opts != null ? opts.documentRoot : void 0
      });
      this.rtspServer = new rtsp.RTSPServer({
        serverName: this.serverName,
        httpHandler: this.httpHandler,
        rtmpServer: this.rtmpServer
      });
      this.rtspServer.on('video_start', (function(_this) {
        return function(stream) {
          return _this.onReceiveVideoControlBuffer(stream);
        };
      })(this));
      this.rtspServer.on('audio_start', (function(_this) {
        return function(stream) {
          return _this.onReceiveAudioControlBuffer(stream);
        };
      })(this));
      this.rtspServer.on('video', (function(_this) {
        return function(stream, nalUnits, pts, dts) {
          return _this.onReceiveVideoNALUnits(stream, nalUnits, pts, dts);
        };
      })(this));
      this.rtspServer.on('audio', (function(_this) {
        return function(stream, accessUnits, pts, dts) {
          return _this.onReceiveAudioAccessUnits(stream, accessUnits, pts, dts);
        };
      })(this));
      avstreams.on('new', function(stream) {
        if (DEBUG_INCOMING_PACKET_HASH) {
          return stream.lastSentVideoTimestamp = 0;
        }
      });
      avstreams.on('reset', function(stream) {
        if (DEBUG_INCOMING_PACKET_HASH) {
          return stream.lastSentVideoTimestamp = 0;
        }
      });
      avstreams.on('end', (function(_this) {
        return function(stream) {
          _this.rtspServer.sendEOS(stream);
          return _this.rtmpServer.sendEOS(stream);
        };
      })(this));
    }

    StreamServer.prototype.stop = function(callback) {
      this.customReceiver.deleteReceiverSocketsSync();
      return typeof callback === "function" ? callback() : void 0;
    };

    StreamServer.prototype.start = function(callback) {
      var seq;
      seq = new Sequent;
      this.rtmpServer.start({
        port: config.rtmpServerPort
      }, function() {
        return seq.done();
      });
      this.customReceiver.start();
      this.rtspServer.start({
        port: config.serverPort
      }, function() {
        return seq.done();
      });
      return seq.wait(2, function() {
        return typeof callback === "function" ? callback() : void 0;
      });
    };

    StreamServer.prototype.setLivePathConsumer = function(func) {
      return this.rtspServer.setLivePathConsumer(func);
    };

    StreamServer.prototype.onReceiveVideoControlBuffer = function(stream, buf) {
      logger.debug("video start");
      stream.resetFrameRate(stream);
      stream.isVideoStarted = true;
      stream.timeAtVideoStart = Date.now();
      return stream.timeAtAudioStart = stream.timeAtVideoStart;
    };

    StreamServer.prototype.onReceiveAudioControlBuffer = function(stream, buf) {
      logger.debug("audio start");
      stream.isAudioStarted = true;
      stream.timeAtAudioStart = Date.now();
      return stream.timeAtVideoStart = stream.timeAtAudioStart;
    };

    StreamServer.prototype.onReceiveVideoDataBuffer = function(stream, buf) {
      var dts, nalUnit, pts;
      pts = buf[1] * 0x010000000000 + buf[2] * 0x0100000000 + buf[3] * 0x01000000 + buf[4] * 0x010000 + buf[5] * 0x0100 + buf[6];
      dts = pts;
      nalUnit = buf.slice(7);
      return this.onReceiveVideoPacket(stream, nalUnit, pts, dts);
    };

    StreamServer.prototype.onReceiveAudioDataBuffer = function(stream, buf) {
      var adtsFrame, dts, pts;
      pts = buf[1] * 0x010000000000 + buf[2] * 0x0100000000 + buf[3] * 0x01000000 + buf[4] * 0x010000 + buf[5] * 0x0100 + buf[6];
      dts = pts;
      adtsFrame = buf.slice(7);
      return this.onReceiveAudioPacket(stream, adtsFrame, pts, dts);
    };

    StreamServer.prototype.onReceiveVideoNALUnits = function(stream, nalUnits, pts, dts) {
      var hasVideoFrame, md5, nalUnit, nalUnitType, tsDiff, _i, _len;
      if (DEBUG_INCOMING_PACKET_DATA) {
        logger.info("receive video: num_nal_units=" + nalUnits.length + " pts=" + pts);
      }
      this.rtspServer.sendVideoData(stream, nalUnits, pts, dts);
      this.rtmpServer.sendVideoPacket(stream, nalUnits, pts, dts);
      hasVideoFrame = false;
      for (_i = 0, _len = nalUnits.length; _i < _len; _i++) {
        nalUnit = nalUnits[_i];
        nalUnitType = h264.getNALUnitType(nalUnit);
        if ((nalUnitType === h264.NAL_UNIT_TYPE_IDR_PICTURE) || (nalUnitType === h264.NAL_UNIT_TYPE_NON_IDR_PICTURE)) {
          hasVideoFrame = true;
          if (!DEBUG_INCOMING_PACKET_HASH) {
            break;
          }
        }
        if (DEBUG_INCOMING_PACKET_HASH) {
          md5 = crypto.createHash('md5');
          md5.update(nalUnit);
          tsDiff = pts - stream.lastSentVideoTimestamp;
          logger.info("video: pts=" + pts + " pts_diff=" + tsDiff + " md5=" + (md5.digest('hex').slice(0, 7)) + " nal_unit_type=" + nalUnitType + " bytes=" + nalUnit.length);
          stream.lastSentVideoTimestamp = pts;
        }
      }
      if (hasVideoFrame) {
        stream.calcFrameRate(pts);
      }
    };

    StreamServer.prototype.onReceiveVideoPacket = function(stream, nalUnitGlob, pts, dts) {
      var nalUnits;
      nalUnits = h264.splitIntoNALUnits(nalUnitGlob);
      if (nalUnits.length === 0) {
        return;
      }
      this.onReceiveVideoNALUnits(stream, nalUnits, pts, dts);
    };

    StreamServer.prototype.onReceiveAudioAccessUnits = function(stream, accessUnits, pts, dts) {
      var accessUnit, i, md5, ptsPerFrame, _i, _len, _results;
      this.rtspServer.sendAudioData(stream, accessUnits, pts, dts);
      if (DEBUG_INCOMING_PACKET_DATA) {
        logger.info("receive audio: num_access_units=" + accessUnits.length + " pts=" + pts);
      }
      ptsPerFrame = 90000 / (stream.audioSampleRate / 1024);
      _results = [];
      for (i = _i = 0, _len = accessUnits.length; _i < _len; i = ++_i) {
        accessUnit = accessUnits[i];
        if (DEBUG_INCOMING_PACKET_HASH) {
          md5 = crypto.createHash('md5');
          md5.update(accessUnit);
          logger.info("audio: pts=" + pts + " md5=" + (md5.digest('hex').slice(0, 7)) + " bytes=" + accessUnit.length);
        }
        _results.push(this.rtmpServer.sendAudioPacket(stream, accessUnit, Math.round(pts + ptsPerFrame * i), Math.round(dts + ptsPerFrame * i)));
      }
      return _results;
    };

    StreamServer.prototype.onReceiveAudioPacket = function(stream, adtsFrameGlob, pts, dts) {
      var adtsFrame, adtsFrames, adtsInfo, i, isConfigUpdated, rawDataBlock, rawDataBlocks, rtpTimePerFrame, _i, _len;
      adtsFrames = aac.splitIntoADTSFrames(adtsFrameGlob);
      if (adtsFrames.length === 0) {
        return;
      }
      adtsInfo = aac.parseADTSFrame(adtsFrames[0]);
      isConfigUpdated = false;
      stream.updateConfig({
        audioSampleRate: adtsInfo.sampleRate,
        audioClockRate: adtsInfo.sampleRate,
        audioChannels: adtsInfo.channels,
        audioObjectType: adtsInfo.audioObjectType
      });
      rtpTimePerFrame = 1024;
      rawDataBlocks = [];
      for (i = _i = 0, _len = adtsFrames.length; _i < _len; i = ++_i) {
        adtsFrame = adtsFrames[i];
        rawDataBlock = adtsFrame.slice(7);
        rawDataBlocks.push(rawDataBlock);
      }
      return this.onReceiveAudioAccessUnits(stream, rawDataBlocks, pts, dts);
    };

    return StreamServer;

  })();

  module.exports = StreamServer;

}).call(this);
